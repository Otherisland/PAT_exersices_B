## 1010 一元多项式求导 (25 分)

设计函数求一元多项式的导数。（注：*x*^n^（*n*为整数）的一阶导数为*nx*^n−1^。）

### 输入格式:

以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以空格分隔。

### 输出格式:

以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是 0，但是表示为 `0 0`。

### 输入样例:

```in
3 4 -5 2 6 1 -2 0
```

### 输出样例:

```out
12 3 -10 1 6 0
```
---
**问题分析：**
- 首先需要注意输入时的方式问题
- 其次需要注意格式问题
- 第三只有零多项式才能使用表示`0 0`的样式，`零多项式`指没有项数
- 注意输入时的格式，和输出时不太一样，输入时不一定有零项

**错误源代码：**
```c
#include <stdio.h>

int main()
{
//	多项式非零项系数和指数
	int arrs[1000];
	int count=0;//系数和指数数量 
	for(;;)
	{
		scanf("%d",&arrs[count]);
		if(arrs[count]==0&&count%2==1) break;//若系数为0，停止采集 
		else count++;
	} 
	
	int i,tail=0;
	for(i=0;i<count-1;i+=2)
	{
		if(arrs[i+1]-1==0) 
		{
			tail=i+1;break;//记录最后那个系数为0的下标 
		}
		printf("%d ",arrs[i]*arrs[i+1]);
		printf("%d ",arrs[i+1]-1);
	}
	
	if(arrs[tail]-1!=0) //若没有系数下标为0的数，则添加一个0 0 
	{
		printf("0 ");
		printf("0");
	}else{
		printf("%d ",arrs[tail-1]*arrs[tail]);
		printf("%d",arrs[tail]-1);
	} 

	
	
	return 0;
}
```
**错误原因：**

> 错误1：没有注意到输入时可以没有系数为0的多项式

**`输入时`系数为0的多项式**

> 错误2：没有注意到零多项式的样式

**即需要添加`0 0`样式的多项式**

**正确源代码如下：**
```c
#include <stdio.h>

int main()
{
//	多项式非零项系数和指数
	int a,b;//系数和指数 
	int count=0;//系数和指数数量 
 	while(scanf("%d %d", &a, &b) != EOF){
        if (a != 0 && b != 0) {
            // 指数不为0且系数不为0
            // 求导后该项才不会为0
            if (count != 0) printf(" "); // 如果是第一个元素，开头无需空格
            printf("%d ", a * b); // 系数
            printf("%d", b - 1); // 指数
            count++;
        }
    }
    if (count == 0) {
        // 说明所有的项求导后都为0，则输出0 0
        printf("0 0");
    }

	return 0;
}
```
**首先需要注意输入时的方式问题
其次需要注意格式问题
第三只有零多项式才能使用表示`0 0`的样式，`零多项式`指没有项数
注意输入时的格式，和输出时不太一样，输入时不一定有零项**