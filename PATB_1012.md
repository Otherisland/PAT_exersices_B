## 1012 数字分类 (20 分)

给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字：

- *A*~1~ = 能被 5 整除的数字中所有偶数的和；
- *A*~2~ = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 *n*~1~−*n*~2~+*n*~3~−*n*~4~⋯；
- *A*~3~ = 被 5 除后余 2 的数字的个数；
- *A*~4~ = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位；
- *A*~5~ = 被 5 除后余 4 的数字中最大数字。

### 输入格式：

每个输入包含 1 个测试用例。每个测试用例先给出一个不超过 1000 的正整数 *N*，随后给出 *N* 个不超过 1000 的待分类的正整数。数字间以空格分隔。

### 输出格式：

对给定的 *N* 个正整数，按题目要求计算 *A*~1~—*A*~5~ 并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。

若分类之后某一类不存在数字，则在相应位置输出 `N`。

### 输入样例 1：

```in
13 1 2 3 4 5 6 7 8 9 10 20 16 18
```

### 输出样例 1：

```out
30 11 2 9.7 9
```

### 输入样例 2：

```in
8 1 2 4 5 6 7 9 16
```

### 输出样例 2：

```out
N 11 2 N 9
```
---
**问题分析：**
- 数字除以5，数字不超过1000
- 整除的数字中，所有偶数的和
- 余1的数字，顺序交错求和
- 余2的数字，数字的个数
- 余3的数字，取平均数，精确到小数点后1位
- 余4，其中的最大数字
- 若分类后某一类不存在数字，则在相应位置输出N

**错误源代码：**
```c
#include <stdio.h>

int main()
{
	int n;//个数
	scanf("%d",&n);
	
	int i;
	int arrs[n];
	int A1=0,A2=0,A3=0,A5=0;
	float A4=0;
	int flag=1;//交错求和运算位 
	int count=0;//记录A4 
	int zero=1; //判断A2是否存在 
	
	for(i=0;i<n;i++)
	{
		scanf("%d",&arrs[i]);
		if(arrs[i]%5==0&&arrs[i]%2==0)//整除5且是偶数 
		{
			A1+=arrs[i]; //偶数和 
		}else if(arrs[i]%5==1)//除以5余1
		{
			A2+= arrs[i]*flag;//交错求和
			flag=(-1)*flag;//每相加一次置反 
			zero=0;//若A2存在，置0 
		} else if(arrs[i]%5==2)//除以5余2 
		{
			A3++;//计算个数 
		}else if(arrs[i]%5==3)//除以5余3
		{
			A4+=arrs[i];//先求和 
			count++; 
		 } else if(arrs[i]%5==4&&A5<arrs[i])//除以5余4
		 {
		 	A5=arrs[i];//寻求最大数 AQ
		 }
	 }  
	 A4=A4/count;//求平均数
	 
	 printf(A1?"%d ":"N ",A1);
	 printf(zero?"N ":"%d ",A2);//A2可能为0，所以需要一个标志位判断
	 printf(A3?"%d ":"N ",A3);
	 printf((A4<=1e-6)?"N ":"%.1f ",A4/count);//错误写法 
	 printf(A5?"%d":"N",A5);
	
	return 0;
}
```

**错误原因：**

> 错误1：令A4=A4/count，直接判断A4是否为0

**因为A4是`float型`，直接判断A4的0与否不够准确。
判断`单精度(float)`是否为0;`if(abs(f)<=1e-6);`
若判断`双精度(double)`是否为0;`if(abs(f)<=1e-15);`**

**正确源代码如下：**
```C
int main()
{
	int n;//个数
	scanf("%d",&n);
	
	int i;
	int arrs[n];
	int A1=0,A2=0,A3=0,A5=0;
	float A4=0;
	int flag=1;//交错求和运算位 
	int count=0;//记录A4 
	int zero=1; //判断A2是否存在 
	
	for(i=0;i<n;i++)
	{
		scanf("%d",&arrs[i]);
		if(arrs[i]%5==0&&arrs[i]%2==0)//整除5且是偶数 
		{
			A1+=arrs[i]; //偶数和 
		}else if(arrs[i]%5==1)//除以5余1
		{
			A2+= arrs[i]*flag;//交错求和
			flag=(-1)*flag;//每相加一次置反 
			zero=0;//若A2存在，置0 
		} else if(arrs[i]%5==2)//除以5余2 
		{
			A3++;//计算个数 
		}else if(arrs[i]%5==3)//除以5余3
		{
			A4+=arrs[i];//先求和 
			count++; 
		 } else if(arrs[i]%5==4&&A5<arrs[i])//除以5余4
		 {
		 	A5=arrs[i];//寻求最大数 AQ
		 }
	 }  
	 
	 printf(A1?"%d ":"N ",A1);
	 printf(zero?"N ":"%d ",A2);//A2可能为0，所以需要一个标志位判断
	 printf(A3?"%d ":"N ",A3);
	 printf(A4?"%.1f ":"N ",A4/count);//若判断单精度(float)是否为0;if(abs(f)<=1e-6);    若判断双精度(double)是否为0;if(abs(f)<=1e-15)；
	 //前面错误都是因为这个A4，原因是不用比大小来判断它是否正确 
	 printf(A5?"%d":"N",A5);
	
	return 0;
}
```